(ns aggregate.core
  (:require [clojure.java.jdbc :as j]
            [clojure.set]
            [clojure.pprint]
            [honeysql.core :as s]
            [honeysql.helpers :refer :all :exclude [update]]))

;;--------------------------------------------------------------------
;; Aggregate structure
;; It is a nested map of entities arranged by entity-kw and entity-id
;; { <entity-kw> { <entity-id> <entity> } .. }
;;
;; Child entities are nested inside the parent entities in a map 
;; { .. <relation-kw> { <child-entity-id> <child entity> .. } }
;; To specify an entity to be a child declare it in parent entity's schema
;; as a :1-n relation.
;;
;; For quick lookup of a child entity which is being referred by another
;; entity, an index map is provided in the aggregate data structure. This
;; is a map of entity id to a vector of keywords and ids denoting the
;; position of this entity in the aggregate.
;; { <child-entity-kw> { <child-entity-id> <index vector of child-entity> .. } }
;; For example, given aggregate agg and a child entity keyword :kw and id,
;; you can lookup the child entity as: (get-in agg (get-in agg [:kw id]))
;;
;; For :m-1 relation, the entity contains the id of target entity.
;; For :m-n relation, the entity contains a set of id of target entities.
;;
;; IMPORTANT!!!
;; The aggregate data structure should at any point be complete with
;; regards to reference entities. There should not be missing any 
;; entity being referred by an entity in it. Otherwise, it might result
;; in undesired effects.
;;
;; The public methods in this package are written such that they maintain
;; this referrential integrity. However, for any modifications done
;; outside of this, must be checked to ensure its whole-ness.
;;
;;--------------------------------------------------------------------
;; The aggregate module works on a entity relationship configuration
;; (refered as 'er-config' here). It is generated by the builder
;; function 'build-er-config' for a given relationship schema.
;;
;; This schema is of form:
;; { <entity-kw>
;;   { :table <table-kw>
;;     :head? <is head?> ;; this will be a top level entity in aggregate
;;     :family <family-kw> ;; to group together some related entities
;;     :uid < :id or kw-collection (kw can be field-kw or relation-kw) >
;;     :fields { <field-kw> { :column <column-kw>
;;                            :read <read-fn> ;; convert on read from db
;;                            :write <write-fn> ;; convert on write to db
;;                            :type <:clob, etc> ;; currently supports only :clob
;;                            :rel {:entity <entity-kw>}
;;                                  :field <field-kw>
;;                                  :where {<field-kw> <value>}}}
;;             ..}
;;     :relations { <relation-kw> { :type <:1-n, :m-1, :m-n>
;;                                  :child-entity <child-entity-kw>
;;                                  :link-table <link-table-kw for many2many>
;;                                  :fk-parent <fk-parent-kw>
;;                                  :fk-child <fk-child-kw> }
;;                ..}}
;;   ..}
;;
;; The relation can be one of three types
;; :m-n, many to many: must specify
;;   link-table: the 3rd table linking parent and child tables
;;   fk-parent: the column in link table refering to this entity (parent)
;;   fk-child: the column in link table refering to other entity (child)
;; :1-n, one to many: specify only
;;   fk-parent: the column in other entity refering to this entity
;; :m-1, many to one: specify only
;;   fk-child: the column in this entity refering to other entity
;;
;; Use :rel in field definition to define dependency on another entity
;; but not linked to it by foreign key. Here :field denotes the field on
;; the target entity to match. Also, :where is a map of additional
;; constraints to be used while matching.


;;--------------------------------------------------------------------
;; Common utilities


(defn- log
  ([xs] ;; for debug tracing
   (clojure.pprint/pprint xs)
   xs)
  ([print? xs] ;; for conditional debug tracing
   (if print? (clojure.pprint/pprint xs))
   xs))


(defn- next-id
  "Gets the next id to use for adding a new entity to an aggregate.
  The current id is tracked using an atom kept in the metadata
  field ::id-counter"
  [agg]
  ^:new {:nid (-> agg meta ::id-counter (swap! inc))})

(defn new-agg
  "Returns an empty aggregate."
  []
  ^{::id-counter (atom 0)} {})

(defn tempid
  "Constructs a temporary id for a new entity based on the given reference which can be
  a number or keyword or even a map."
  [ref]
  ^:new {:tid ref})

(defn- dissoc-in
  "Remove the nested key for the given path as a key sequence"
  [m ks]
  (let [pks (drop-last ks) k (last ks)]
    (if (empty? pks)
      (dissoc m k)
      (update-in m pks #(if (map? %) (dissoc % k) %)))))

(defn- keep-ks
  "Removes all but ks keys from map m."
  [m ks]
  (let [ks-set (set ks)]
    (into {} (filter (comp ks-set first) m))))

(defn- add-meta [obj mmap]
  (with-meta obj (merge (meta obj) mmap)))
(defn- get-meta [obj key]
  (if key (-> obj meta key)))
(defn- get-meta-in [obj key-vec]
  (-> obj meta (get-in key-vec)))

(defn- kw-comp
  "Combine the given keyword names putting '.' in-between
  and return as a keyword"
  [pk & cks]
  (keyword (str (name pk) (apply str (map #(str "." (name %)) cks)))))

(defn- map->map
  "Transform the given map by replacing each value by applying the 
  given function. The function should take the key and value pair as
  its input."
  [f m]
  (reduce (fn [m k] (update m k #(f k %)))
          m (keys m)))

(defn- map-match
  "Returns back the map m, if has same contents of map fm in it,
  else returns nil."
  [m fm]
  (reduce (fn [m [k v]]
            (if (and m (= v (get m k))) m)) m fm))

(defn- map-filter
  "Checks and returns avilable matches.
  If input is a map of maps, returns a list of pairs [id matched-map].
  If input is a collection of maps, returns the list of matched-maps.
  If no matches found, returns empty list."
  [ms fm]
  (if (map? ms)
    (filter #(map-match (val %) fm) ms)
    (filter #(map-match % fm) ms)))

(defn- merge-deep [a b]
  (cond
    (nil? a) b
    (nil? b) a
    (and (map? a) (map? b))
    (reduce (fn [a [i bi]] (update a i #(merge-deep % bi))) a b)
    (and (coll? a) (= (type a) (type b))) (into a b)
    true b))

(defn reduce-agg
  "Process each entity and reference in given aggregate using given
   processing functions and initial value.
   Usage: (reduce-agg [er-config init agg ;; required args
                       ;; optional args
                       :order order :ent-fn efun :ref-fn rfun])
     init: initial value
     agg: the aggregate of entities
     order: vector of head-entity keywords to process only these and
            in that order. All others will be skipped!
     efun: takes a vector [init ekw iv e] and returns updated init.
           by default it is 'first' to return init unchanged.
     rfun: takes a vector [init ekw iv ckw rt r] and returns update init
           by default it is 'first' to return init unchanged.
     ekw: the entity keyword
     iv: the index vector of the entity in aggregate
     ckw: the entity keyword of the reference entity
     rt: the type of reference, :1-n or :m-1 or :m-n
     r: the reference, if rt = :m-1 it is a single id else set of ids

  agg can be any data structure matching the schema er-config. however
  the entity meta data is not required."
  [er-config init agg & {efun :ent-fn rfun :ref-fn order :order
                         :or {efun first rfun first order []}}]
  (let [order (or (not-empty order) (get-meta er-config ::load-order))
        order (filter #(get-in er-config [% :head?]) order)]
    (reduce
     (fn _proc-fn [init [ekw iv e entity?]]
       (if (empty? e) init
           (if entity?
             (reduce (fn [init [rkw {rt :type ckw :child-entity}]]
                       (if-let [r (rkw e)]
                         (rfun [(if (= :1-n rt)
                                  (_proc-fn init [ckw (conj iv rkw) r false])
                                  init)
                                ekw (conj iv rkw) ckw rt r])

                         init))
                     (efun [init ekw iv e])
                     (-> er-config ekw :relations))
             (reduce _proc-fn init
                     (map (fn [[i ei]] [ekw (conj iv i) ei true]) e)))))
     init
     (map (fn [k] [k [k] (k agg) false]) order))))

(defn ensure-entity-meta
  "This takes in an aggregate data structure manually prepared by you or obtained
  from elsewhere, and returns an aggregate by adding additional meta data."
  [er-config agg]
  (let [agg (if (get-meta agg ::id-counter) agg ;;ensure ::id-counter present
                (add-meta agg {::id-counter (atom 0)}))]
    (reduce-agg er-config agg agg
                :ent-fn
                (fn [[agg ekw iv e]]
                  (if (get-meta e ::entity) agg
                      (assoc-in agg iv (add-meta e {::entity ekw})))))))

(defn- walk-uids
  "Walks from parent node to child nodes applying the given function f
  at each node. The aggregate consists of multiple trees of node. In each
  each tree the walk is from the root (a head entity) towards its branches.
  However, between the trees themselves, there is no particular order.
  To control the order between trees, specify the fourth argument
  'order', a sequence of head entity keywords. Any unspecified
  entity keywords will result in corresponding trees being skipped.

  init: the seed value for acumulation through walk
  f: the function to be applied at each node.
  It must take in [init uiv uid frm] and update/return init
  init: the accumulated value just before processing current node
  uiv: the index vector of the current node
  uid: the key of the current node
  frm: value (the frame) at the current node"
  ([uids f init]
   (walk-uids uids f init nil))
  ([uids f init order]
   (let [order (if (not-empty order)
                 (map #(conj [] % (uids %) []) order)
                 (map #(conj % []) uids))]
     (reduce
      (fn _wu-fn [init [uid frm puiv]]
        (let [uiv (conj puiv uid)]
          (reduce _wu-fn
                  (f init uiv uid frm)
                  (map #(conj % uiv) frm))))
      init
      order))))

(defn- build-uid [er-config ekw iv e agg]
  (if-let [uid (get-meta (get-in agg iv) :uid)]
    [uid agg]
    (let [{ks :keys rks :rel-keys} (-> er-config ekw :uid)
          [uid agg]
          (reduce
           (fn [[uid agg]
                [rkw {ckw :child-entity}]]
             ;; for :m-1 relation, just uid of the that entity itself is
             ;; not enough. Must include uids of its parent and grand parent
             ;; entities as well to uniquely identify it. Hence uiv (index
             ;; vector of uid) is used.
             (loop [aiv []
                    civ (let [civ [ckw (rkw uid)]]
                          (if (-> er-config ckw :head?)
                            civ (get-in agg civ)))
                    akw nil
                    cuiv []
                    agg agg]
               (let [arkw (first civ)
                     aiv (conj aiv arkw (second civ))
                     akw (if (not akw) arkw
                             (get-in er-config
                                     [akw :relations arkw :child-entity]))
                     ae (get-in agg aiv)
                     [auid agg] (build-uid akw aiv ae agg)
                     cuiv (conj cuiv arkw auid)
                     ;; data for next iteration
                     civ (drop 2 civ)]
                 (if (not-empty civ)
                   (recur aiv civ akw cuiv agg)
                   [(assoc uid rkw cuiv) agg]))))
           [(reduce #(assoc %1 %2 (%2 e)) {} ks) agg]
           (filter #(and (rks (key %)) ((key %) e))
                   (-> er-config ekw :relations)))]
      [uid
       (assoc-in agg iv (add-meta e {:uid uid}))])))

(defn unique-ids
  "To generate a nested map of uid for each entity in the given aggregate. This
  map provides a common basis between aggregates loaded from different databases
  to identify corresponding entities, since this is not dependent on the default
  row ids from the database tables, which are often auto generated and not
  necessarily maintained identical.

  The uid is actually a map of a few fields picked from the entity such that, this
  would be the basis to uniquely identify that entity. The choice of the fields
  is specified in the er-config schema by the :uid key in each entity.

  It is also possible to specify a foreign key as a uid key. In that case, the uid
  of the referred entity will be included instead of its id."
  [er-config agg]
  (let [[uids agg]
        (reduce-agg
         er-config [{} agg] agg
         :ent-fn
         (fn [[[uids agg] ekw iv e]]
           (if-let [uid-spec (get-in er-config [ekw :uid])]
             (let [[uid agg]
                   (if (= uid-spec :id)
                     [(last iv) (update-in agg iv #(add-meta % {:uid (last iv)}))]
                     (build-uid er-config ekw iv e agg))
                   piv (drop-last iv)
                   uiv (if (second piv)
                         (let [puiv (get-meta (get-in agg (drop-last piv)) :uiv)]
                           (conj puiv (last piv) uid))
                         [ekw uid])
                   uids (assoc-in uids uiv ^{:iv iv :ekw ekw :id (last iv)} {})
                   agg (update-in agg iv #(add-meta % {:uiv uiv ::entity ekw}))]
               [uids agg])
             (throw (Throwable. (str "Failed to build unique ids. Missing :uid spec for "
                                     ekw))))))]
    (add-meta uids {::agg agg})))

;;--------------------------------------------------------------------
;; Factories for default DB access functions based on clojure.java.jdbc and honeysql

(defn- clob-to-string
  "Read a CLOB and return the full text as a string"
  [clob]
  (if clob
    (with-open [rdr (java.io.BufferedReader. (.getCharacterStream clob))]
      (apply str (line-seq rdr)))))

(defn- rt?
  "Is relation of type?
  Returns true if the relation-type equals t."
  [t [_ relation]]
  ((if (coll? t) (into #{} t) #{t})
   (:type relation)))

(defn- select-fields
  "Augments the fields map with additional field entries selected
   from the relations map based on specified rel-types."
  [fields relations rel-types]
  (reduce (fn [fs [rel-kw {column :fk-child}]]
            (assoc fs rel-kw {:column column}))
          fields
          (filter #(rt? rel-types %) relations)))
(def ^:private select-fields-memo
  "memoized version for better performance"
  (memoize select-fields))

(defn- row-2-entity
  "Maps the row retrieved from database to an entity using the fields map.
   Incldue: those specified under :fields (transform using read fn if given)
          & those relations with :type = :m-1 (no transformation)"
  [rows fields relations]
  (let [fields+ (select-fields-memo fields relations :m-1)]
    (apply map (comp  #(apply hash-map %) concat)
           (map (fn [[field {:keys [column read]
                             :or {read identity}}]]
                  (map (fn [row]
                         [field (let [v (column row)] (read v))])
                       rows))
                fields+))))

(defn- entity-2-row
  "Maps the entity to a row suitable for database using the fields and
   relations map.
   Include: those specified under :fields (transform using write fn if given)
          & those relations with :type = :m-1 (no transformation)"
  ([entities fields relations field-filter]
   (let [fields+ (filter field-filter
                         (select-fields-memo fields relations :m-1))]
     (apply map (comp  #(apply hash-map %) concat)
            (map (fn [[field {:keys [column write]
                              :or {write identity}}]]
                   (map (fn [entity]
                          [column (let [v (field entity)]
                                    (if (map? v) (:id v) (write v)))])
                        entities))
                 fields+))))
  ([entities fields relations]
   (entity-2-row entities fields relations identity)))


(defn- where-conds
  [fkeys fields]
  (let [wcs (map (fn [f]
                   (if-let [c (-> fields f :column)]
                     [:= c (keyword (str \? (name f)))]))
                 fkeys)]
    (cond
      (->> wcs (filter nil?) count pos?) nil
      (->> wcs count (= 1)) (first wcs)
      :else (into [:and] wcs))))

(def ^:private where-conds-memo
  "memozed version for better performance"
  (memoize where-conds))

(defn- make-read-fn
  "Returns a read function [db-spec id -> row-map] for a specific table.
  The function returns a single record or nil when id is spcified
      and returns a list of records or empty list when a filter map is
      specified or id-or-fmap is not specified."
  [{:keys [table fields relations]}]
  (let [fields+ (select-fields-memo fields relations :m-1)
        columns (map #(-> % val :column) fields+)
        clobs (map key (filter #(= :clob (-> % val :type)) fields+))
        id-column (-> fields :id :column)
        sql-by-id (first (s/format (-> (apply select columns)
                                       (from table)
                                       (where [:= id-column :?id]))))
        sql-all (s/format (-> (apply select columns)
                              (from table)))
        row-fn (if (empty? clobs) identity
                   (fn [row]
                     (reduce (fn [r f] (update r f #(clob-to-string %)))
                             row clobs)))]
    (fn _read-fn
      [db-spec id-or-fmap]
      (if (map? id-or-fmap)
        (if (empty? id-or-fmap)
          (if-let [rows (j/query db-spec sql-all :row-fn row-fn)]
            (row-2-entity rows fields relations))
          (let [fmap id-or-fmap
                wcs (where-conds-memo (keys fmap) fields+)]
            (if-let
                [rows
                 (and wcs
                      (j/query db-spec
                               (s/format
                                (-> (apply select columns)
                                    (from table)
                                    (where wcs))
                                (map->map
                                 #(if-let [rf (-> fields+ % :write)]
                                    (rf %2)
                                    %2)
                                 fmap))
                               :row-fn row-fn))]
              (row-2-entity rows fields relations))))
        (if-let [id id-or-fmap]
          (if-let [rows (j/query db-spec [sql-by-id id] :row-fn row-fn)]
            (row-2-entity rows fields relations)))))))

(defn- make-insert-fn
  "Returns an insert function [db-spec row-map -> row-map] for an entity.
  It returns the record, augmented with the id in an :id slot.
  It assumes that all :m-1 type relations are already saved
  and their id is present in entity."
  [{:keys [table fields relations uid]}]
  (let [sikw (keyword "scope_identity()")
        nid-fn (fn [m]
                 (if-let [nid (sikw m)] nid
                   (-> m :rowid .stringValue)))
        id-col (get-in fields [:id :column])
        _apfn (fn [m row]
                (merge (if (and (= uid :id)
                                (not (get-meta (:id row) :new)))
                         row ;; same id only if insisted
                         (dissoc row id-col)) ;; auto create id in db
                       (or m {})))
        id-sql (first (s/format (-> (select id-col)
                                    (from table)
                                    (where [:= :rowid :?rowid]))))]
    (fn [db-spec entity pim]
      (let [row (->> (entity-2-row [entity] fields relations) first
                   (_apfn pim)) ;;add parent entity info and keep id if applicable
            res (first (j/insert! db-spec table row))
            nid (or (id-col row)
                    (case (:subprotocol db-spec)
                      "oracle" (->> res :rowid .stringValue
                                    (#(j/query db-spec [id-sql %]))
                                    first id-col)
                      (or (get res sikw)
                          (get res :id)
                          (throw (Throwable. "Unknown insert result format.
 Do not know how to extract id")))))]
        (assoc entity :id nid)))))


(defn- make-update-fn
  "Returns an update function [db-spec set-map -> set-map] for a
  specific table, which takes a map of values and updates the record
  denoted by the :id contained in set-map. It returns the set-map."
  [{:keys [table fields relations]}]
  (let [id-col (get-in fields [:id :column])
        id-sql (str (name id-col) " = ?")]
    (fn [db-spec set-map]
      (if (not (:id set-map))
        (throw (Throwable. "Cannot update entity. Missing :id"))
        (do
          (let [field-set (apply hash-set (keys set-map))
                field-filter (fn [[field _]] (field-set field))]
            (->> (entity-2-row [set-map] fields relations field-filter)
                 first
                 (#(j/update! db-spec table % [id-sql (:id set-map)]))))
          set-map)))))


(defn- make-delete-fn
  "Returns a delete function [db-spec id-or-fmap -> n] for a specific
  table, which deletes the record id points to. It returns the number
  of deleted records (usually 1), or nil if none was deleted."
  [{table :table
    {{id-col :column} :id :as fields} :fields
    relations :relations}]
  (let [id-sql (str (name id-col) " = ?")
        fields+ (select-fields-memo fields relations :m-1)]
    (fn [db-spec id-or-fmap]
      (let [n (if (map? id-or-fmap)
                (let [fmap id-or-fmap
                      wcs (where-conds-memo (keys fmap) fields+)]
                  (j/execute! db-spec
                              (s/format (-> (delete-from table)
                                            (where wcs))
                                        (map->map
                                         #(if-let [rf (-> fields+ % :write)]
                                            (rf %2)
                                            %2)
                                         fmap))))
                (let [id id-or-fmap]
                  (j/delete! db-spec table [id-sql id])))
            n (first n)]
        (if (> n 0) n nil)))))


(defn- make-query-fn
  "Returns a function to query for related child entities.
   Only applicable for <To Many> relation type.
        :m-1 : nil
        :1-n : fn that returns list of child entity
        :m-n : fn that returns list of child id"
  [er-config parent-entity-kw relation-kw]
  (let [ parent-entity (er-config parent-entity-kw)
        {relation-type :type
         child-entity-kw :child-entity
         link-table :link-table
         fk-parent :fk-parent
         fk-child :fk-child}
        (get-in parent-entity [:relations relation-kw])]
    (case relation-type
      :1-n ;;fn to return list of child entity
      (let [child-entity (assoc-in (er-config child-entity-kw)
                                   [:fields :__PARENT__ :column]
                                   fk-parent)
            read-fn (make-read-fn child-entity)]
        (fn [db-spec id-parent]
          (map #(dissoc % :__PARENT__)
               (read-fn db-spec {:__PARENT__ id-parent}))))
      :m-n ;;fn to return list of child id
      (let [sql (first (s/format (-> (select fk-child)
                                     (from link-table)
                                     (where [:= fk-parent :?pid]))))]
        (fn [db-spec id-parent]
          (map fk-child
               (j/query db-spec [sql id-parent]))))
      ;; for other types not applicable
      nil)))

(defn- make-update-links-fn
  "Returns a function that updates a link table by first deleting all
  records having a-id as value in the field fk-a, and afterwards
  inserting for each of the bs one record with fk-a = a-id and fk-b
  = (:id b)."
  [relation-kw relation]
  (if (= :m-n (:type relation))
    (let [{:keys [link-table fk-parent fk-child]} relation
          q-sql (first
                 (s/format (-> (select fk-child)
                               (from link-table)
                               (where [:= fk-parent :?id]))))]
      (fn [db-spec entity]
        (let [{id-parent :id
               ids-child relation-kw} entity
               ids-from-db (into #{}
                                 (map fk-child
                                      (j/query db-spec [q-sql id-parent])))
               ids-to-del (clojure.set/difference ids-from-db ids-child)
               ids-to-ins (clojure.set/difference ids-child ids-from-db)]
          (if (not (empty? ids-to-del))
            (j/execute! db-spec
                        (s/format (-> (delete-from link-table)
                                      (where [:in fk-child :?l]))
                                  ;;using the in clause and passing the id list in sql
                                  ;; only good for few items (less than 1000)
                                  {:l ids-to-del})))
          (if (not (empty? ids-to-ins))
            (apply j/insert! db-spec link-table
                   (map (fn [cid] {fk-parent id-parent
                                   fk-child cid}) ids-to-ins))))))))
(defn- make-delete-links-fn
    "Returns a function that updates a link table by deleting all
  records having a-id as value in the field fk-a"
  [relation-kw relation]
  (if (= :m-n (:type relation))
    (let [{:keys [link-table fk-parent fk-child]} relation
          id-sql (str (name fk-parent) " = ?")]
      (fn [db-spec id]
        (j/delete! db-spec link-table [id-sql id])))))

(defn- shared-entities [er-config]
  {:hard (apply clojure.set/union
                (map (fn [[ekw ecfg]]
                       (into #{} (map (fn [[k r]] (:child-entity r))
                                      (filter #(rt? #{:m-1 :m-n} %)
                                              (:relations ecfg)))))
                     er-config))
   :soft (reduce
          (fn [ents [ekw ecfg]]
            (reduce
             (fn [ents [f {{re :entity :as r} :rel}]]
               (if-not re ents
                       (update ents re #(conj (or % #{}) r))))
             ents (:fields ecfg)))
          {} er-config)})

(defn- add-head-query-sql
  "Augment the er-config with additional info to help determine and load
  the head entity containing the desired child entity."
  [er-config]
  (let [{shared-ents :hard} (shared-entities er-config)]
    (reduce
     (fn _bce-fn [er-config [ekw ecfg hekw [[ct cid cfk] & r :as tcv]]]
       (let [er-config
             (if-not ekw
               er-config
               (let [head-sql
                     (if r
                       (let [sql (-> (select [(kw-comp ct cfk) :id])
                                     (from ct))
                             sql (reduce (fn [sql [cta cida cfka ctb cidb cfkb]]
                                           (join sql ctb [:=
                                                          (kw-comp cta cida)
                                                          (kw-comp ctb cfkb)]))
                                         sql
                                         (map #(into %1 %2) tcv r))
                             [lct lcid lcfk] (last r)
                             sql (where sql [:= (kw-comp lct lcid) :?id])]
                         (first (s/format sql)))
                       (let [sql (-> (select [cfk :id])
                                     (from ct)
                                     (where [:= cid :?id]))]
                         (first (s/format sql))))]
                 (assoc er-config
                        ekw
                        (assoc ecfg
                               :head-entity hekw
                               :head-sql head-sql))))]
         (reduce _bce-fn
                 er-config
                 (map (fn [[rkw {cekw :child-entity :as rel}]]
                        (let [cecfg (cekw er-config)]
                          [(shared-ents cekw) cecfg hekw
                           (conj tcv [(:table cecfg)
                                      (-> cecfg :fields :id :column)
                                      (:fk-parent rel)])]))
                      (filter #(rt? :1-n %) (:relations ecfg))))))
     er-config
     (map (fn [[hekw hecfg]]
            [nil hecfg hekw []])
          (filter #(-> % val :head?) er-config)))))

(defn- get-dependency-level
  "Determines how deep is the dependency level of each entity. The higher
   the level, the more nested are the entities depending on it. This is
   for determining the order of loading."
  [er-config]
  (reduce
   (fn _blvl-fn [lvl-map [ekw ecfg]]
     (let [lvl-map (update lvl-map ekw #(or % 1))
           clvl (inc (ekw lvl-map))]
       (reduce
        (fn [lvl-map [rkw {cekw :child-entity rt :type}]]
          (let [cecfg (er-config cekw)]
            (if (#{:m-1 :m-n} rt)
              (let [hekw (if (:head? cecfg) cekw (:head-entity cecfg))
                    hecfg (er-config hekw)]
                (if (> clvl (or (hekw lvl-map) 1))
                  (_blvl-fn (assoc lvl-map hekw clvl) [hekw hecfg])
                  lvl-map))
              (_blvl-fn (assoc lvl-map cekw (dec clvl)) [cekw cecfg]))))
        lvl-map
        (:relations ecfg))))
   {}
   (filter #(-> % val :head?) er-config)))

(defn- make-soft-dep-fn
  "Augment the er-config with helper functions to work with entities that
  are related but has no explicit database link defined."
  [f {rf :field rw :where :as rel}]
  (let [ks (conj (or (keys rw) []) rf)]
    (assoc rel
           :key-fn ;;extract entity keys
           #(into {}
                  (map (fn [k] [k (k %)]) ks))
           :match-fn ;;match entity
           (fn [k e] (map-match e (assoc rw rf k)))
           :filter-fn ;;match multiple entities (collection or id map)
           (fn [k es] (map-filter es (assoc rw rf k))))))
(def ^:private make-soft-dep-fn-memo
  (memoize make-soft-dep-fn))

(defn build-er-config [er-config]
  (let [er-config
        (map->map
         (fn [ekw ecfg]
           (let [ecfg (assoc ecfg
                             :fields (reduce ;;process fields denoting soft dependency
                                      ;; provide convinience fn for matching a dependency
                                      ;; entity for a specified key (this field value).
                                      (fn [fields [f {rel :rel}]]
                                        (update-in fields [f :rel]
                                                   (partial make-soft-dep-fn-memo f)))
                                      (:fields ecfg)
                                      (filter #(-> % val :rel) (:fields ecfg))))
                 ecfg (assoc ecfg
                             :uid (case (:uid ecfg)
                                    (:id [:id] #{:id}) :id
                                    (nil [] #{}) (throw (Throwable. (str "Missing :uid spec for " ekw)))
                                    (let [fs (into #{}
                                                   (remove #(= % :id)
                                                           (keys (:fields ecfg))))
                                          rs (into #{}
                                                   (map key (filter #(rt? :m-1 %)
                                                                    (:relations ecfg))))
                                          rfs (clojure.set/union rs fs)
                                          ks (:uid ecfg)
                                          ks (if (coll? ks) (into #{} ks) #{ks})
                                          ks (let [dks (clojure.set/difference ks rfs)]
                                               (if (ks :id)
                                                 (throw (Throwable.
                                                         (str "Error processing " ekw
                                                              ". :uid spec can not have both :id and other fields"))))
                                               (if (not-empty dks)
                                                 (throw (Throwable.
                                                         (str "Error processing " ekw
                                                              ". Unknown fields/relations in :uid spec: "
                                                              dks))))
                                               ks)
                                          rks (clojure.set/intersection ks rs)
                                          ks (clojure.set/union ks rks)]
                                      {:keys ks :rel-keys rks})))
                 ecfg (assoc ecfg
                             :read-fn (make-read-fn ecfg)
                             :insert-fn (make-insert-fn ecfg)
                             :update-fn (make-update-fn ecfg)
                             :delete-fn (make-delete-fn ecfg)
                             :relations
                             (map->map
                              (fn [rkw rel]
                                (assoc rel
                                       :query-fn (make-query-fn er-config ekw rkw)
                                       :update-links-fn (make-update-links-fn rkw rel)
                                       :delete-links-fn (make-delete-links-fn rkw rel)))
                              (:relations ecfg)))]
             ecfg))
         er-config)
        shared-ents (shared-entities er-config)
        er-config (add-head-query-sql er-config)
        lvl-map (get-dependency-level er-config)]
    (add-meta er-config
              {::dep-entities shared-ents ;;non-head entities having dependants
               ::dep-level lvl-map ;;higher number -> more deeply nested dependants
               ::load-order (mapv key ;;higher level to load first
                                  (sort #(> (val %1) (val %2))
                                        (filter #(or ((:hard shared-ents) (key %))
                                                     (-> er-config ((key %)) :head?))
                                                lvl-map)))})))



;;--------------------------------------------------------------------
;; Common utility functions for the big three: load, save! and delete!


(defn- gather-soft-dependency
  [er-config agg]
  (let [shared-ents (get-meta-in er-config [::dep-entities :soft])]
    (reduce-agg
     er-config [{} {}] agg
     :ent-fn (fn [[[avls reqs] ekw iv e]]
               [(reduce (fn [avls {kfn :key-fn :as rel}]
                          (update avls ekw
                                     #(conj (or % #{})
                                            (kfn e))))
                        avls
                        (shared-ents ekw))
                (reduce
                 (fn [reqs
                      [f {{re :entity
                           rf :field
                           rw :where} :rel}]]
                   (if-let [rv (f e)]
                     (update reqs re
                                #(conj (or % #{}) (assoc rw rf rv)))
                     reqs))
                 reqs
                 (filter #(-> % val :rel) (-> er-config ekw :fields)))]))))


(defn- gather-hard-dependency
  [er-config entities]
  (let [ind-ents (into #{}
                       (remove #(-> er-config % :head?)
                               (get-meta-in er-config [::dep-entities :hard])))
        entity-kw (get-meta (first entities) ::entity)
        agg {entity-kw (into {} (map (fn [e] [(:id e) e]) entities))}]
    (if-not entity-kw [{} {}]
            (reduce-agg
             er-config [{} {}] agg
             :ent-fn
             (fn [[[inds reqs] ekw iv e]]
               [(if-not (ind-ents ekw) inds
                        (assoc-in inds [ekw (:id e)] iv))
                reqs])
             :ref-fn
             (fn [[[inds reqs] ekw iv ckw rt r]]
               [inds
                (if-not (#{:m-1 :m-n} rt) reqs
                        (let [cids (if (= rt :m-1) #{r} r)]
                          (update reqs ckw
                                     #(clojure.set/union (or % #{}) cids))))])))))





;;--------------------------------------------------------------------
;; Load aggregate

(declare load-entity)

(defn- load-relation
  "Loads more data according to the specified relation."
  [er-config db-spec m
   [relation-kw
    {:keys [type child-entity link-table fk-parent query-fn]}]]
  (assoc m
         relation-kw
         (if (= :1-n type) ;;more child entities
           (let [cs (->> (query-fn db-spec (:id m))
                     (map #(add-meta % {::entity child-entity}))
                     (map (partial load-entity er-config db-spec)))]
             (reduce #(assoc %1 (:id %2) (dissoc %2 :id)) {} cs)) ;;map of cid to centity
           (if (= :m-n type) ;;set of child ids
             (into #{} (query-fn db-spec (:id m)))
             (relation-kw m)))))

(defn- load-entity
  "Loads an entity, the entity-kw denotes the aggregate root and
  id-or-fmap is the id or a filter map (field and value to match).
  Returns a map containing the entity-kw in ::entity and all data, or
  nil if the entity-kw is unknown or the record does not exist."
  ([er-config db-spec entity-kw id-or-fmap]
   (let [read-fn (-> er-config entity-kw :read-fn)
         es (if read-fn ;;first shallow load
              (map #(add-meta % {::entity entity-kw})
                   (read-fn db-spec id-or-fmap)))]
     (map (partial load-entity er-config db-spec) es))) ;;now deep load
  ([er-config db-spec m-or-kw]
   (if (keyword? m-or-kw)
     (load-entity er-config db-spec m-or-kw {}) ;;blank filter to load all
     (let [m m-or-kw] ;;deep load the given entity
       (if-let [entity-kw (get-meta m ::entity)]
         (let [relations (-> er-config entity-kw :relations)]
           (reduce (partial load-relation er-config db-spec)
                   m
                   (filter #(rt? #{:1-n :m-n} %) relations))))))))

(defn- _load-head-entity ;; first step : load hard links
  "Load the head entity along with all related entities. As the child entities are
   nested inside others, an index vector to look them up is also provided.
   'agg' is an previously loaded aggregate for merging and optimize the loading
   of shared child entities.
   Returns the entities/indices as map of map: {entity-kw {entity-id entity-or-ind}}"
  ([er-config db-spec entity-kw id-or-fmap]
   (_load-head-entity er-config db-spec entity-kw id-or-fmap (new-agg)))
  ([er-config db-spec entity-kw id-or-fmap agg]
   (if-not
       (-> er-config entity-kw :head?) agg
       (let [hes (load-entity er-config db-spec entity-kw id-or-fmap)
             load-order (get-meta er-config ::load-order)
             [inds reqs] (gather-hard-dependency er-config hes)
             ;;add entities to aggregate
             agg (reduce (fn [agg e] (assoc-in agg [entity-kw (:id e)] (dissoc e :id)))
                         agg hes)
             ;;add index to aggregate
             agg (reduce (fn [agg [k m]] (update agg k #(merge % m)))
                         agg inds)]
         ;;load the requirement
         (reduce
          (fn [agg [ekw ids]]
            (reduce
             (fn [agg id]
               (if (get-in agg [ekw id])
                 agg
                 (let [{head? :head?
                        hkw :head-entity
                        hsql :head-sql} (ekw er-config)]
                   (if head?
                     (_load-head-entity er-config db-spec ekw id agg)
                     (let [{hid :id} (first (j/query db-spec [hsql id]))]
                       (if (get-in agg [hkw hid])
                         agg
                         (_load-head-entity er-config db-spec hkw hid agg)))))))
             agg ids))
          agg
          (filter #(second %)
                  (map (fn [k] [k (k reqs)]) load-order)))))))

(defn load-head-entity ;; second step : load soft links
  "Load the head entity along with all related entities. As the child entities are
   nested inside others, an index vector to look them up is also provided.
   'agg' is an previously loaded aggregate for merging and optimize the loading
   of shared child entities.
   Alos loads the dependency entities as defined in er-config.
   Returns the entities/indices as map of map: {entity-kw {entity-id entity-or-ind}}"
  ([er-config db-spec entity-kw id-or-fmap]
   (load-head-entity er-config db-spec entity-kw id-or-fmap (new-agg)))
  ([er-config db-spec entity-kw id-or-fmap agg]
   (j/with-db-transaction [db-conn db-spec]
     (loop [agg (_load-head-entity er-config db-spec entity-kw id-or-fmap agg)
            done {}]
       (let [[avls reqs] (gather-soft-dependency er-config agg)
             to-load ;;determine what needs to be loaded
             (reduce
              (fn [reqs k]
                (let [a (or (avls k) #{})
                      b (or (done k) #{})]
                  (if (and (empty? a) (empty? b)) reqs
                      (update reqs k #(clojure.set/difference % a b)))))
              reqs (keys reqs))]
         (if (pos? (apply + (map count (vals to-load))))
           (let [agg
                 (reduce (fn [agg [ekw fs]]
                           (reduce (fn [agg f]
                                     (_load-head-entity er-config
                                                        db-conn ekw f agg))
                                   agg
                                   fs))
                         agg
                         to-load)]
             (recur agg (merge-deep done to-load)))
           agg))))))

(defn load-family-heads
  "Load the head entities in the specified family. Entities are loaded without
  child entities. Useful for selecting those for full load.
  Returns the head entities as a map of map: {entity-kw {entity-id entity}}"
  ([er-config db-spec family-kw]
   (load-family-heads er-config db-spec family-kw (new-agg)))
  ([er-config db-spec family-kw agg]
   (j/with-db-transaction [db-conn db-spec]
     (let [load-order  (get-meta er-config ::load-order)
           fs (if (coll? family-kw) (into #{} family-kw) #{family-kw})]
       (reduce (fn [agg ekw]
                 (let [read-fn (-> er-config ekw :read-fn)
                       es (read-fn db-conn {})]
                   (reduce #(assoc-in %1 [ekw (:id %2)] (dissoc %2 :id))
                           agg es)))
               agg
               (filter #(let [{f :family h? :head?} (er-config %)]
                          (and h? (fs f)))
                       load-order))))))

(defn load-family
  "Load the complete collection of entities in the specified family. Any related
   child entities are also included inside the head entities. As the child entities
   are nested inside others, an index vector to look them up is also provided.
   Returns the entities/indices as a map of map: {entity-kw {entity-id entity-or-ind}}"
  ([er-config db-spec family-kw]
   (load-family er-config db-spec family-kw (new-agg)))
  ([er-config db-spec family-kw agg]
   (j/with-db-transaction [db-conn db-spec]
     (let [load-order  (get-meta er-config ::load-order)
           fs (if (coll? family-kw) (into #{} family-kw) #{family-kw})]
       (reduce #(load-head-entity er-config db-conn %2 {} %1)
               agg
               (filter #(let [{f :family h? :head?} (er-config %)]
                          (and h? (fs f)))
                       load-order))))))


;;--------------------------------------------------------------------
;; Delete aggregate

(declare delete-entity!)

(defn- delete-relation!
  "Deletes a record that is a relation of m.
  For 1-n relation deletes all child records.
  For m-n relation deletes all link records."
  [er-config db-spec m
   [rkw {:keys [link-table fk-parent] :as rel}]]
  (case (:type rel)
    :1-n  (apply + (map (partial delete-entity! er-config db-spec)
                        (map (fn [[cid cm]] (assoc cm :id cid))
                             (get m rkw))))
    :m-n (first (j/delete! db-spec link-table
                           [(str (name fk-parent) " = ?") (:id m)]))
    0 ;;default value must be provided to handle no relation case
    ))


(defn delete-entity!
  [er-config db-spec m]
  (if (not (:id m)) (throw (Throwable. "Failed to delete entity! Missing :id")))
  (or
   (j/with-db-transaction [db-conn db-spec]
     (if-let [entity-kw (get-meta m ::entity)]
       (when-let [delete-fn (-> er-config entity-kw :delete-fn)]
         (let [;; delete all dependant records
               r (apply + (map (partial delete-relation! er-config db-conn m)
                               (->> er-config entity-kw :relations
                                    (filter (partial rt? [:1-n :m-n])))))
               ;; delete this record
               n (delete-fn db-conn (:id m))
               n (or n 0)]
           (+ r (or n 0))))))
   0))

(defn delete-agg!
  "Removes an aggregate datastructure from the database."
  [er-config db-spec agg]
  (let [order (filter (fn [ekw]
                        (first (reduce (fn [[ok? m] cfn]
                                 [(and ok? (cfn m)) m])
                               [true (er-config ekw)]
                               [(comp not :read-only?) :head?])))
                      (get-meta er-config ::load-order))
        order (reverse order)] ;;delete order is reverse of dependency
    (j/with-db-transaction [db-conn db-spec]
      (apply
       + (map (fn [ekw]
                (apply
                 + (map (fn [ent] (delete-entity! er-config db-conn ent))
                        (map (fn [[id ent]] (assoc ent :id id))
                             (get agg ekw)))))
              order)))))

;;--------------------------------------------------------------------
;; Save aggregate

;; IMPORTANT!!!
;; Unique Id of an child entity is assummed to include parent entity
;; If it is not the case with database, error may occur while inserting
;; two child entity under two different parent entity, but with rest of
;; the unique id being same. Since the database doesn't consider the
;; parent as the part of unique constraint, it will throw error since
;; this would be considered as duplicate keys by the database.

(defn- get-entity [id ekw agg]
  (let [e (get-in agg [ekw id])]
    (if (map? e) e (get-in agg e)))) ;;lookup again if an index
(defn- id-2-uiv [id ekw agg]
  (get-meta (get-entity id ekw agg) :uiv))
(defn- uiv-2-id [uiv uids]
  (get-meta (get-in uids uiv) :id))
(defn- uiv-2-iv [uiv uids]
  (get-meta (get-in uids uiv) :iv))
(defn- iv-2-uiv [iv agg]
  (get-meta (get-in agg iv) :uiv))
(defn- iv-2-iv [iv agg1 uids2]
  (uiv-2-iv (iv-2-uiv iv agg1) uids2))


(defn- register-insert-or-update [er-config changes nids
                                  target-uids target-agg
                                  source-uids source-agg uiv]
  ;; register the change: insert or update
  ;; compare the entity at position given by the unique index vector - uiv
  ;; self needs update if any changes to
  ;;   fields excluding :id
  ;;   relations :m-1
  ;; needs to update links if any changes to :m-n relations
  ;; update the target-agg to reflect additions to current node only
  ;;   Do not go on adding child nodes (:1-n) as that is taken care by
  ;; the caller who is walking down the uids trees in the order of
  ;; dependency, starting from independent head entities.
  (let [frm (get-in source-uids uiv)
        {:keys [ekw iv]} (meta frm)
        tfrm (get-in target-uids uiv)
        ent (get-in source-agg iv)
        {:keys [fields relations uid]} (er-config ekw)


        [action tfrm tent tiv nids] ;;obtain target entity (create new if missing)
        (if tfrm
          (let [tiv (get-meta tfrm :iv)] ;;existing entity
            [nil tfrm (get-in target-agg tiv) tiv nids])
          (let [id (last iv)             ;;insert new entity
                tid (if (and (= uid :id)
                             (not (get-meta id :new)))
                      id ;; persist id
                      (next-id target-agg)) ;;dummy id
                puiv (drop-last 2 uiv)
                tiv (if (empty? puiv) [ekw tid]
                        (let [tpiv (uiv-2-iv puiv target-uids)]
                          (conj tpiv (last (drop-last iv)) tid)))
                tfrm ^{:iv tiv :ekw ekw :id tid} {}
                tent ^{:uiv uiv :uid (last uiv) ::entity ekw} {}
                nids (if (= id tid) nids (assoc-in nids [ekw id] tid))]
            [:insert tfrm tent tiv nids]))

        cfs (reduce (fn [cfs [f _]]     ;;gather changed fields
                      (let [tv (f tent) v (f ent)]
                        (if (or (= f :id) (= tv v)) cfs
                            (assoc cfs f v))))
                    {} fields)

        target-uids (assoc-in target-uids uiv tfrm)
        target-agg (assoc-in target-agg tiv tent)

        cm1s (reduce ;;gather changed :m-1 relations
              (fn [cm1s [rkw {cekw :child-entity}]]
                (let [id (rkw ent)
                      tid (-> (id-2-uiv id cekw source-agg)
                              (uiv-2-id target-uids))]
                  (if (= tid (rkw tent)) cm1s
                      (assoc cm1s rkw tid))))
              {} (filter #(rt? :m-1 %) relations))

        cmns (reduce ;;gather changed :m-n relations
              (fn [cmns [rkw {cekw :child-entity}]]
                (let [tids (into #{} (map #(-> %
                                               (id-2-uiv cekw source-agg)
                                               (uiv-2-id target-uids))
                                          (rkw ent)))]
                  (if (= tids (or (rkw tent) #{})) cmns
                      (assoc cmns rkw tids))))
              {} (filter #(rt? :m-n %) relations))

        cks (into [] (mapcat keys [cfs cm1s]))
        action (or action (if (or (not-empty cks) (not-empty cmns)) :update))
        
        ;; for child entity, gather information to resolve parent id
        tpiv (not-empty (drop-last 2 tiv))
        pniv (if (and (= action :insert) tpiv) ;;to lookup the new id of parent
              (let [pekw (get-meta (get-in target-agg tpiv) ::entity)
                    fk (get-in er-config [pekw :relations
                                          (last (drop-last tiv)) :fk-parent])]
                {:fk fk :iv [pekw (last tpiv)]}))
        changes (if-not action changes
                        (conj changes
                              [action tiv
                               (case action
                                 :update cks
                                 :insert pniv
                                 nil)
                               (keys cmns)]))

        tfrm (add-meta tfrm {:action action})
        tent (merge tent cfs cm1s cmns)

        target-uids (assoc-in target-uids uiv tfrm)
        target-agg (assoc-in target-agg tiv tent)]
    [changes nids target-uids target-agg]))

(defn- register-delete [er-config changes target-uids target-agg tuiv tiv]
  ;; delete order
  ;;  :m-n links, :1-n -> self
  (let [tent (get-in target-agg tiv)
        tfrm (get-in target-uids tuiv)
        {:keys [id ekw]} (meta tfrm)
        uiv (get-meta tent :uiv)
        target-uids (dissoc-in target-uids tuiv)
        target-agg (dissoc-in target-agg tiv)
        [changes target-agg]
        ((fn _rd-fn [changes t-agg frm]
           (let [{:keys [ekw id]} (meta frm)
                 frms (mapcat #(-> % val vals) frm)
                 [changes t-agg] (reduce _rd-fn changes t-agg frms)
                 t-agg (dissoc-in t-agg [ekw id]) ;;remove any index
                 changes (conj changes [:delete ekw id])]
             [changes t-agg]))
         changes target-agg tfrm)]
    [changes target-uids target-agg]))

(defn merge-agg
  [er-config source target]
  (let [editable? (reduce (fn [s [ekw {:keys [read-only?]}]]
                            (if read-only? s (conj s ekw)))
                          #{} er-config)
        [[source-agg source-uids] ;; obtain the uids and agg separated
         [target-agg target-uids]] (mapv #(if-let [agg (get-meta % ::agg)]
                                            [agg (add-meta % {::agg nil})]
                                            (let [uids (unique-ids er-config %)
                                                  agg (get-meta uids ::agg)]
                                              [agg (add-meta uids {::agg nil})]))
         [source target])
         order (get-meta er-config ::load-order)
         target-agg (if (get-meta target-agg ::id-counter) target-agg
                        (add-meta target-agg {::id-counter (atom 0)}))

         ;;first pass: forward order, add from source to target
         [changes nids target-uids target-agg]
         (walk-uids source-uids
                    (fn [[changes nids target-uids target-agg] uiv uid frm]
                      (let [tfrm (get-in target-uids uiv)]
                        (if (or (keyword? uid) ;;skip if not an entity node
                                (not (editable? (get-meta frm :ekw))) ;;read only
                                (get-meta tfrm :action)) ;;skip if already processed
                          ;;no-op
                          [changes nids target-uids target-agg]
                          ;;k: uid, v: childs {kw {uid {}}
                          (register-insert-or-update er-config changes nids
                                                     target-uids target-agg
                                                     source-uids source-agg uiv))))
                    [[] {} target-uids target-agg] order)

         ;;second pass: reverse order, delete extras from target
         [changes target-uids target-agg]
         (walk-uids target-uids
                    (fn [[changes target-uids target-agg] uiv tuid tfrm]
                      (if (or (keyword? tuid) ;;skip if not an entity node
                              (get-meta tfrm :action) ;;skip if already processed
                              (get-in source-uids uiv) ;;skip if not extra
                              (not (get-in target-uids uiv))) ;;skip if already deleted
                        ;;no-op
                        [changes target-uids target-agg]
                        ;;check delete case (delete only child entity, but not head)
                        (if (= 2 (count uiv))
                          [changes
                           (update-in target-uids uiv
                                      #(add-meta % {:action :ignore}))
                           target-agg] ;; head entity, skip delete
                          (if (= :ignore
                                 (get-meta (get-in target-uids (take 2 uiv)) :action))
                            [changes target-uids target-agg]
                            (register-delete er-config changes
                                             target-uids target-agg
                                             uiv (get-meta tfrm :iv))))))
                    [changes target-uids target-agg] (reverse order))]
    [changes nids (add-meta target-uids {::agg target-agg})]))

(defn- uid-2-ufmap
  "Translates the given unique id to a map of unique values that can be used
  as filter to query the entity from database. Resolves any relations used in
  unique id to actual id of the entity as present in the given aggregate."
  [er-config t-uids ekw uid]
  (let [rel-keys (get-in er-config [ekw :uid :rel-keys])
        t-agg (get-meta t-uids ::agg)]
    (reduce (fn [ufmap rkw]
              (if-let [rv (rkw uid)]
                (assoc ufmap rkw (-> (get-in t-uids rv) (get-meta :id)))
                ufmap))
            uid rel-keys)))

(defn- apply-nids [er-config ekw ent nids]
  (reduce (fn [m [rt rkw ckw]]
            (if-let [nid (case rt
                           :m-1
                           (if-let [oid (rkw m)]
                             (get-in nids [ckw oid]))
                           :m-n
                           (if-let [oid (not-empty (rkw m))]
                             (into #{}
                                   (map #(if-let [i (get-in nids [ckw %])] i %)
                                        oid)))
                           nil)]
              (assoc m rkw nid)
              m))
          ent
          (map (fn [[rkw {rt :type ckw :child-entity}]] [rt rkw ckw])
               (get-in er-config [ekw :relations]))))

(defn- apply-db-insert! [er-config db-spec uids agg nids [tiv pniv links]]
  (let [ent (assoc (get-in agg tiv) :id (last tiv))
        ekw (get-meta ent ::entity)
        ent (apply-nids er-config ekw ent nids)
        insert-fn (get-in er-config [ekw :insert-fn])
        update-links-fns (map #(get-in er-config [ekw :relations % :update-links-fn])
                              links)
        pid (if-let [fk (:fk pniv)]
              {fk (if-let [id (get-in nids (:iv pniv))] id
                          (last (drop-last 2 tiv)))}
              {})
        nent (insert-fn db-spec ent pid)
        nids (let [oid (:id ent)
                   nid (:id nent)]
               (if (= oid nid) nids
                   (assoc-in nids [ekw oid] nid)))]
    (doall (map #(% db-spec nent) update-links-fns))
    nids))

(defn- apply-db-update! [er-config db-spec uids agg nids [tiv fields links]]
  (let [ent (assoc (get-in agg tiv) :id (last tiv))
        ekw (get-meta ent ::entity)
        ent (apply-nids er-config ekw ent nids)
        set-map (keep-ks ent (conj fields :id))
        update-fn (get-in er-config [ekw :update-fn])
        update-links-fns (map #(get-in er-config [ekw :relations % :update-links-fn])
                              links)
        set-map (if (not-empty fields) (update-fn db-spec set-map))]
    (doall (map #(% db-spec ent) update-links-fns))
    nids))

(defn- apply-db-delete! [er-config db-spec [ekw id]]
  (let [delete-fn (get-in er-config [ekw :delete-fn])
        delete-links-fns (remove nil? (map #(-> % val :delete-links-fn)
                                           (get-in er-config [ekw :relations])))]
    (doall (map #(% db-spec id) delete-links-fns))
    (delete-fn db-spec id)))

(defn save-agg!
  [er-config db-spec agg]
  (let [uids (unique-ids er-config agg)
        agg (get-meta uids ::agg)]
    (j/with-db-transaction [db-conn db-spec]
      (let [t-agg
            (reduce (fn [t-agg ekw]
                      (let [t-uids (unique-ids er-config t-agg)
                            t-agg (get-meta t-uids ::agg)
                            uid-spec (get-in er-config [ekw :uid])]
                        (reduce (fn [t-agg [uid _]]
                                  (if (and (= :id uid-spec) (get-meta uid :new))
                                    t-agg ;;when :uid is by :id, uid is id. if it is new, no need to check database
                                    (let [ufmap (uid-2-ufmap er-config t-uids ekw uid)]
                                      (load-head-entity er-config db-conn ekw ufmap t-agg))))
                                t-agg
                                (ekw uids))))
                    (new-agg)
                    (filter #(-> er-config % :head?) (get-meta er-config ::load-order)))
            [changes nids t-uids] (merge-agg er-config uids t-agg)
            t-agg (get-meta t-uids ::agg)

            t-nids
            (reduce (fn [t-nids c]
                      (case (first c)
                        :insert (apply-db-insert! er-config db-conn t-uids t-agg t-nids (rest c))
                        :update (apply-db-update! er-config db-conn t-uids t-agg t-nids (rest c))
                        :delete (do (apply-db-delete! er-config db-conn (rest c))
                                    t-nids)
                        t-nids))
                    {} changes)
            nids (reduce (fn [nids [ekw ids]]
                           (let [t-ids (ekw t-nids)]
                             (assoc nids ekw
                                    (into {}
                                          (map (fn [[oid nid]] [oid (get t-ids nid)])
                                               ids)))))
                         nids nids)]
        {:new-id nids}))))
